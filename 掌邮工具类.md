# 掌邮工具类

## 说明

1. 记录一些自定义的第三方库，并且给出相关代码示例

## 模版 (Swift)

```Markdown

### <#基建名字#>
<#作者等基础信息介绍#>

<#这是一段介绍#>

2. <#特别需要注意的属性#>

<#使用时是否需要注意掉用属性的顺序#>

3. <#公开的一些使用方法#>

<#使用时是否需要考虑特殊情况#>

```

## Pod

### [CocoaPods]

[新Mac装CocoaPods](https://juejin.cn/post/7249584657599938597)



### [Homebrew] (https://brew.sh/index_zh-cn)



### [Git LFS] (https://docs.github.com/en/repositories/working-with-files/managing-large-files/installing-git-large-file-storage?platform=mac)

因为接入了 **FluentDarkModeKit**，且现在很多大厂都喜欢lfs，所以要下载 git-lfs

```ruby
brew install git-lfs.
```



### [RY] 

孙思瑞 (@RySi Sun) QQ: 2769119954

> 因为接入了网校学生的第三方库，这里需要注意，其他人的自定义第三库请自己定义一个前缀！

a. 记得更新本地 repo

```ruby
pod repo update
```

b. 记得更新代码

```ruby
pod update
```

--------------------------------------------------

## 记录


### Constants

系统以及扩展

孙思瑞 (@RySi Sun) QQ: 2769119954

Constants 是一个获取一些系统的东西，例如 statusBarHeight 等，请不要随意添加扩展，一定要考虑所有情况

```Swift

let statusBarHeight = Constants.statusBarHeight

let systemVersion = Constants.systemVersion

```


UIButton+Cyxbs 是对 UIButton 的扩展，是用来布局 image 和 title 位置的代码，利用 swizzle 解决

> https://blog.csdn.net/zxw_xzr/article/details/64920473
> 这个是利用 swizzle + runtime
>
> https://blog.51cto.com/u_7583030/6391659
> 这个是利用 EdgeInsets
>
> 为什么最终还是选择 swizzle？ 因为没法确定 UIButton 的大小是否会变化

```Swift

let btn = UIButton()
btn.frame.size = CGSize(width: 40, height: 80)
btn.setTitle("测试", for: .normal)
btn.setImage(UIImage(named: "Test"), for: .normal)
btn.set(imageViewSize: CGSize(width: 30, height: 30), imagePostion: .top, spaceForMiddle: 5)

```




### NetWork

网络请求库

孙思瑞 (@RySi Sun) QQ: 2769119954



SessionManager 不直接使用！！！，这个类作为嫁接类，实际上请使用 HttpManager

但 SessionManager 作为扩展，你可以在里面添加一些通参，或作中间处理

并且请查看 NetError 以及 NetResponse



HttpManager 作为掉用类，里面书写了所有涉及到的API，对应后端给的所有API，集中管理！

在你写项目的时候，请参照这个模版去做

a. ** 你的API为 `/magipoke-jwzx/kebiao`，那你的命名为 `magipoke_jwzx_kebiao` **

b. ** 你的参数为 `"stu_num": <String>`，那参数则为 `(stu_num: String)` **

c. ** 如果参数不明确，可以更改你的参数传递，并书写注释或更为通俗易懂 **


```Swift

@discardableResult
func magipoke_jwzx_kebiao(stu_num: String) -> DataRequest {
    let parameters: [String: String] = [
        "stu_num": stu_num
    ]
    return SessionManager.shared.request(APIConfig.api("/magipoke-jwzx/kebiao"), method: .post, parameters: parameters)
}

```



APIConfig 是获取 API 的类

这里引入了三种环境，如果要切换云端环境，请使用 `APIConfig.askCloud(success:)` 去请求

```Swift

APIConfig.askCloud { enviroment in
    APIConfig.environment = enviroment
}

```





### CacheManager

缓存管理

孙思瑞 (@RySi Sun) QQ: 2769119954

CacheManager 总的管理者，在发版之前，请检查 **cleanInNextVersion** 

如果需要清理前一个版本的缓存，那么请把 cleanInNextVersion 设置为 true

```Swift

// 创建 file，一般情况下不用掉用
CacheManager.shared.create(rootPath: .document, file: "test/test/test")

// 将一个 SwiftyJSON 对象存入
CacheManager.shared.cache(json: model, in: .init(rootPath: .document, file: "ScheduleModel/sno2021215154"))

// 取出一个 SwiftyJSON 对象
CacheManager.shared.getJOSN(in: .init(rootPath: .document, file: "ScheduleModel/sno\(scheduleModel.sno)"))

```



CacheManager.FilePath 路径类

创建更具 根路径RootPath 和 名字file 创建

可以利用这个类来创建文件夹



CacheManager.RootPath 根路径

因为可能涉及小组件的共享路径，所以这里单独提出来，并做扩展

```Swift

extension CacheManager.RootPath {
    
    static let document: Self = .init(NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first ?? "")
}

```





### Theme

主题颜色

孙思瑞 (@RySi Sun) QQ: 2769119954

**ThemeProtocol** 是一个协议，它规定了 **主题颜色** 需要遵守的协议

a. 如果你想添加新的协议，请仿照 ThemeProtocol 的其他协议

b. `func color<T: UIColor>(_ property: KeyPath<ThemeProtocol, T>) -> T` 用于快速返回其中的color值



**WhiteTheme** 与 **DarkTheme** 是遵循 ThemeProtocol 协议的，其作用是用来返回正常的白天黑夜

a. 其中，有部分颜色没用到，并且以注释为 `[T]` 开头，寓意 **Test**，你可以修改他们，并及时更改注释

b. WhiteTheme 与 DarkTheme 不一定要一一对应，参考下面 UIColor+Theme 文档

c. 以 `[F]` 开头的，代表与 Figma 标识一致

d. 以 `[L]` 开头的，代表与 Lanhu 标识一致



**UIColor+Theme**

接入 **FluentDarkModeKit** 第三方库，如果有大佬愿意的话，可以考虑以后手搓，并欢迎和我交流技术

定义了一个中间结构体 `struct _ry: ThemeProtocol`，其符合 ThemeProtocol 协议

a. 利用 `extension UIColor` 中定义静态常量 `static let ry = _ry()`，达到可以使用 `UIColor.ry` 的语法访问

b. 在 **CGColor** 中，使用完整拼写`UIColor.ry`；在 **UIColor** 中，则可以直接拼写`.ry`



**UIColor._ry**

`_ry` 结构体定义了三个获取UIColor的方式

```Swift
    func color(light: UIColor, dark: UIColor) -> UIColor {
        .init(.dm, light: light, dark: dark)
    }
    
    func make<T: UIColor>(_ property: KeyPath<ThemeProtocol, T>) -> UIColor {
        color(light: whiteTheme.color(property), dark: darkTheme.color(property))
    }
    
    func make<T: UIColor, U: UIColor>(_ tProperty: KeyPath<ThemeProtocol, T>, _ uProperty: KeyPath<ThemeProtocol, U>) -> UIColor {
        color(light: whiteTheme.color(tProperty), dark: darkTheme.color(uProperty))
    }
```

使用方法：

```Swift

func test1() {
    let lab = UILabel()
    lab.textColor = .ry.titleColorForPlace_main
}

func test2() {
    let lab = UILabel()
    lab.textColor = .ry.make(\.backgroundColorForPlace_tabBar, \.titleColorForPlace_main)
}

func test3() {
    let lab = UILabel()
    lab.textColor = .ry.color(light: .hex("#114514"), dark: .hex("#415411"))
}

```
